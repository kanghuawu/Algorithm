See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  FAILED (0 errors, 2 warnings)
API:          PASSED

Findbugs:     PASSED
PMD:          PASSED
Checkstyle:   PASSED

Correctness:  41/64 tests passed
Memory:       10/10 tests passed
Timing:       159/159 tests passed

Aggregate score: 73.44%
[Compilation: 5%, API: 5%, Findbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
2.4K Feb 19 21:13 BurrowsWheeler.java
1.3K Feb 19 21:13 CircularSuffixArray.java
1.8K Feb 19 21:13 MoveToFront.java


********************************************************************************
*  COMPILING                                                                    
********************************************************************************


% javac CircularSuffixArray.java
*-----------------------------------------------------------

% javac BurrowsWheeler.java
*-----------------------------------------------------------
BurrowsWheeler.java:42: warning: [rawtypes] found raw type: Deque
        Deque<Integer>[] order = new Deque[R];
                                     ^
  missing type arguments for generic class Deque<E>
  where E is a type-variable:
    E extends Object declared in interface Deque
BurrowsWheeler.java:42: warning: [unchecked] unchecked conversion
        Deque<Integer>[] order = new Deque[R];
                                 ^
  required: Deque<Integer>[]
  found:    Deque[]
2 warnings

% javac MoveToFront.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
CircularSuffixArray:

BurrowsWheeler:

MoveToFront:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS                                       
********************************************************************************


% findbugs *.class
*-----------------------------------------------------------


================================================================


% pmd .
*-----------------------------------------------------------


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for CircularSuffixArray.java
*-----------------------------------------------------------

% custom checkstyle checks for BurrowsWheeler.java
*-----------------------------------------------------------

% custom checkstyle checks for MoveToFront.java
*-----------------------------------------------------------


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of CircularSuffixArray
*-----------------------------------------------------------
Running 15 total tests.

Test 1: check index() and length() with random binary strings
  * length = 10
    - string = "BABAAABBBB"
    - mismatch in indices
    - student   index(4) = 9
    - reference index(4) = 2

    - failed on trial 1 of 1000

  * length = 100
    - string = "BABBBBABBAAAABBABBBBBABBABABBBBBBBAABBABAABBBAAAABBBAABAABAB..."
    - mismatch in indices
    - student   index(0) = 99
    - reference index(0) = 77

    - failed on trial 1 of 1000

  * length = 1000
    - string = "BABBBAABBBBAAAAAABABABBBBBBBBABABBABBBBBAAABBABAABABABABABAA..."
    - mismatch in indices
    - student   index(0) = 999
    - reference index(0) = 967

    - failed on trial 1 of 1000

==> FAILED

Test 2: check index() and length() with random uppercase strings
  * length = 10
    - string = "XJGKFWFCXW"
    - mismatch in indices
    - student   index(6) = 9
    - reference index(6) = 5

    - failed on trial 1 of 1000

  * length = 100
    - string = "ELVHRPMCMAUZFDIMGZPLEXWPNSPZWJFAVNZSHNWMTHFAQJKLMMHVMMGOSXUS..."
    - mismatch in indices
    - student   index(66) = 99
    - reference index(66) = 83

    - failed on trial 2 of 1000

  * length = 1000
    - string = "TAGJJPNSQFUANACWKVLBOCKZLERWUUQALJDEYDBWPDEMMCVOMCMFKNENUDFX..."
    - mismatch in indices
    - student   index(922) = 999
    - reference index(922) = 986

    - failed on trial 1 of 1000

==> FAILED

Test 3: check index() and length() with random ASCII strings
  * length = 10
    - string = hex representation: 14 07 67 69 16 49 6c 50 49 14 
    - mismatch in indices
    - student   index(1) = 9
    - reference index(1) = 0

    - failed on trial 50 of 1000

  * length = 100
    - string = hex representation: 00 1a 68 68 00 0e 70 1c 65 4c 30 65 66 07 1c 5f 41 01 5f 13 ...
    - mismatch in indices
    - student   index(0) = 0
    - reference index(0) = 45

    - failed on trial 3 of 1000

  * length = 1000
    - string = hex representation: 38 20 5d 18 00 74 02 08 3b 40 79 29 5d 59 05 16 57 15 6d 26 ...
    - mismatch in indices
    - student   index(0) = 4
    - reference index(0) = 317

    - failed on trial 1 of 1000

==> FAILED

Test 4: check index() and length() with random extended ASCII strings
  * length = 10
    - string = hex representation: 63 02 16 d1 b9 5e 77 2e e3 63 
    - mismatch in indices
    - student   index(4) = 9
    - reference index(4) = 0

    - failed on trial 24 of 1000

  * length = 100
    - string = hex representation: e7 a7 89 f9 b6 50 e8 46 af 16 86 2d 10 60 f2 85 c4 a3 89 90 ...
    - mismatch in indices
    - student   index(60) = 99
    - reference index(60) = 8

    - failed on trial 3 of 1000

  * length = 1000
    - string = hex representation: c6 44 f6 d0 6a a5 c2 40 c0 fe 8b d6 ab b0 af 58 6f 50 b1 8d ...
    - mismatch in indices
    - student   index(207) = 999
    - reference index(207) = 479

    - failed on trial 1 of 1000

==> FAILED

Test 5: check index() and length() with strings from text files
  * cadabra.txt
    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

  * amendments.txt
    - string = "Article I. Congress shall make no law respecting an establis..."
    - mismatch in indices
    - student   index(0) = 18368
    - reference index(0) = 14383

  * moby1.txt
    - string = "Call me Ishmael. Some years ago- never mind how long precise..."
    - mismatch in indices
    - student   index(0) = 12217
    - reference index(0) = 10396

  * dickens1000.txt
    - string = "It was the best of times, it was the worst of times, it was ..."
    - mismatch in indices
    - student   index(759) = 999
    - reference index(759) = 969

==> FAILED

Test 6: check index() and length() with strings from binary files
  * us.gif
    - string = hex representation: 47 49 46 38 39 61 8e 01 01 01 d5 00 00 94 18 29 06 02 03 84 ...
    - mismatch in indices
    - student   index(0) = 12398
    - reference index(0) = 206

  * CS_bricks.jpg
    - string = hex representation: ff d8 ff e1 00 16 45 78 69 66 00 00 4d 4d 00 2a 00 00 00 08 ...
    - mismatch in indices
    - student   index(0) = 4
    - reference index(0) = 403

  * rand1K.bin
    - string = hex representation: 91 a6 be ff 17 30 3b c2 90 4c dc 6f 14 73 64 27 04 6b 87 8a ...
    - mismatch in indices
    - student   index(683) = 999
    - reference index(683) = 574

==> FAILED

Test 7: check index() and length() with random strings of length 0, 1, and 2
  * length = 0
  * length = 1
  * length = 2
==> passed

Test 8: check that index() throws an exception when argument is out of bounds
  * string of length 10
  * string of length 100
  * string of length 2
  * string of length 1
  * string of length 0
==> passed

Test 9: check that constructor throws an exception when argument is null
==> passed

Test 10: check that two CircularSuffixArray objects can be created at the same time
  * cadabra.txt and amendments.txt
    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

    - string = "Article I. Congress shall make no law respecting an establis..."
    - mismatch in indices
    - student   index(0) = 18368
    - reference index(0) = 14383

  * amendments.txt and cadabra.txt
    - string = "Article I. Congress shall make no law respecting an establis..."
    - mismatch in indices
    - student   index(0) = 18368
    - reference index(0) = 14383

    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

  * dickens1000.txt and cadabra.txt
    - string = "It was the best of times, it was the worst of times, it was ..."
    - mismatch in indices
    - student   index(759) = 999
    - reference index(759) = 969

    - string = "CADABRA!ABRA"
    - mismatch in indices
    - student   index(1) = 11
    - reference index(1) = 6

==> FAILED

Test 11: check that CircularSuffixArray is immutable
  * string = "FXEEJWMLKZVMGKXUTHYFJTHBTFJYKW"
  * string = "AAAAAAAABBAABBAABBBBBABABAABAB"
  * string = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
  * string = hex representation: 25 72 d0 a9 bc 9e 14 05 dc 49 f7 10 81 ac d4 
==> passed

Test 12: check index() and length() with corner-case strings
  * a.txt
  * nomatch.txt
  * zebra.txt
  * alphanum.txt
==> passed

Test 13: check index() and length() with strings that are nontrivial circular
         that are nontrivial circular suffixes of themselves
  * stars.txt
  * couscous.txt
==> passed

Test 14: check index() and length() with unary strings
  * length 10 string over unary alphabet
  * length 100 string over unary alphabet
  * length 1000 string over unary alphabet
==> passed

Test 15: check index() and length() with random strings
         that are nontrivial circular suffixes of themselves
  * length 2 string over binary alphabet, repeated 2 times
  * length 2 string over binary alphabet, repeated 10 times
  * length 5 string over binary alphabet, repeated 2 times
    - string = "ABAAAABAAA"
    - mismatch in indices
    - student   index(0) = 9
    - reference index(0) = 2

    - failed on trial 3 of 5

  * length 5 string over binary alphabet, repeated 3 times
    - string = "BBAABBBAABBBAAB"
    - mismatch in indices
    - student   index(6) = 14
    - reference index(6) = 1

    - failed on trial 1 of 5

  * length 5 string over binary alphabet, repeated 5 times
    - string = "BABAABABAABABAABABAABABAA"
    - mismatch in indices
    - student   index(0) = 24
    - reference index(0) = 3

    - failed on trial 1 of 5

  * length 7 string over uppercase alphabet, repeated 2 times
    - string = "ULHVPOPULHVPOP"
    - mismatch in indices
    - student   index(6) = 13
    - reference index(6) = 4

    - failed on trial 4 of 5

  * length 7 string over uppercase alphabet, repeated 3 times
  * length 7 string over uppercase alphabet, repeated 5 times
==> FAILED

Total: 7/15 tests passed!


================================================================
Testing correctness of MoveToFront
*-----------------------------------------------------------
Running 23 total tests.

Test 1a: check main() on text files
  * java MoveToFront - < abra.txt
  * java MoveToFront - < zebra.txt
  * java MoveToFront - < amendments.txt
  * java MoveToFront - < aesop.txt
==> passed

Test 1b: check main() on text files
  * java MoveToFront + < abra.txt.mtf
  * java MoveToFront + < zebra.txt.mtf
  * java MoveToFront + < amendments.txt.mtf
  * java MoveToFront + < aesop.txt.mtf
==> passed

Test 2a: check that main() is consistent with encode() on text files
  * abra.txt
  * zebra.txt
  * amendments.txt
  * aesop.txt
==> passed

Test 2b: check that main() is consistent with decode() on text files
  * abra.txt.mtf
  * zebra.txt.mtf
  * amendments.txt.mtf
  * aesop.txt.mtf
==> passed

Test 3a: check encode() on text files
  * abra.txt
  * zebra.txt
  * amendments.txt
  * aesop.txt
  * stars.txt
  * alphanum.txt
  * a.txt
==> passed

Test 3b: check encode() on binary files
  * us.gif
  * CS_bricks.jpg
  * rand10K.bin
==> passed

Test 3c: check encode() on random inputs
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 1000 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 3d: check encode() on more random inputs
  * 1000 random characters from ASCII alphabet 
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 4a: check decode() on move-to-front-encoded text files
  * abra.txt.mtf
  * zebra.txt.mtf
  * amendments.txt.mtf
  * aesop.txt.mtf
  * stars.txt.mtf
  * alphanum.txt.mtf
  * a.txt.mtf
==> passed

Test 4b: check decode() on move-to-front encoded binary files
  * us.gif.mtf
  * CS_bricks.jpg.mtf
  * rand10K.bin.mtf
==> passed

Test 4c: check decode() on random inputs
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 1000 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 4d: check decode() on more random inputs
  * 1000 random characters from ASCII alphabet 
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 4e: check decode() on random inputs
         that were encoded with move-to-front
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 1000 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 4f: check decode() on more random inputs
         that were encoded with move-to-front
  * 1000 random characters from ASCII alphabet 
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 5a: check whether decode(encode()) = original on text files
  * abra.txt
  * zebra.txt
  * amendments.txt
  * aesop.txt
  * stars.txt
  * alphanum.txt
  * a.txt
==> passed

Test 5b: check whether decode(encode()) = original on binary files
  * us.gif
  * CS_bricks.jpg
  * rand10K.bin
==> passed

Test 5c: check that decode(encode()) = original on random inputs
  * 10 random characters from { A } alphabet
  * 10 random characters from { A, B } alphabet
  * 10 random characters from { A, T, C, G } alphabet
  * 10 random characters from uppercase letter alphabet
  * 100 random characters from { A } alphabet
  * 1000 random characters from { A, B } alphabet
  * 1000 random characters from { A, T, C, G } alphabet
  * 1000 random characters from uppercase letter alphabet
==> passed

Test 5d: check that decode(encode()) = original on random inputs
  * 1000 random characters from ASCII alphabet 
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 6a: check that encode() calls either close() or flush()
  * amendments.txt
  * aesop.txt
==> passed

Test 6b: check that decode() calls either close() or flush()
  * amendments.txt.mtf
  * aesop.txt.mtf
==> passed

Test 7a: check encode() on large files
  * rand100K.bin
  * world192.txt
==> passed

Test 7b: check decode() on large files
  * rand100K.bin.mtf
  * world192.txt.mtf
==> passed

Test 7c: check whether decode(encode()) = original on large files
  * rand100K.bin
  * world192.txt
==> passed


Total: 23/23 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference CircularSuffixArray)
********************************************************************************

Testing correctness of BurrowsWheeler
*-----------------------------------------------------------
Running 26 total tests.

Test 1a: check main() on text files
  * java BurrowsWheeler - < abra.txt
  * java BurrowsWheeler - < zebra.txt
  * java BurrowsWheeler - < cadabra.txt
  * java BurrowsWheeler - < amendments.txt
==> passed

Test 1b: check main() on text files
  * java BurrowsWheeler + < abra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 21
    - reference entry = 41
    - student:   21 41 42 52 41 43 41 44 41 42 52 41 
    - reference: 41 42 52 41 43 41 44 41 42 52 41 21 

  * java BurrowsWheeler + < zebra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 61
    - reference entry = 7a
    - student:   61 7a 65 62 72 
    - reference: 7a 65 62 72 61 

  * java BurrowsWheeler + < cadabra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 43 41 44 41 42 52 41 21 41 42 52 
    - reference: 43 41 44 41 42 52 41 21 41 42 52 41 

  * java BurrowsWheeler + < amendments.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 72 74 69 63 6c 65 20 .. 74 65 72 76 65 6e 65 64 2e 
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a 

==> FAILED

Test 2a: check that main() is consistent with transform() on text files
  * abra.txt
  * zebra.txt
  * cadabra.txt
  * amendments.txt
==> passed

Test 2b: check that main() is consistent with inverseTransform() on text files
  * abra.txt.bwt
  * zebra.txt.bwt
  * cadabra.txt.bwt
  * amendments.txt.bwt
==> passed

Test 3a: check transform() on text files
  * abra.txt
  * zebra.txt
  * cadabra.txt
  * amendments.txt
==> passed

Test 3b: check transform() on corner-case text files
  * alphanum.txt
  * a.txt
==> passed

Test 3c: check transform() on binary files
  * us.gif
  * CS_bricks.jpg
  * rand10K.bin
==> passed

Test 3d: check transform() on random inputs
  * 10 random characters from binary alphabet
  * 10 random characters from DNA alphabet
  * 10 random characters from uppercase alphabet
  * 1000 random characters from binary alphabet
  * 1000 random characters from DNA alphabet
  * 1000 random characters from uppercase alphabet
==> passed

Test 3e: check transform() on more random inputs
  * 1000 random characters from ASCII alphabet 
  * 1000 random characters from extended ASCII alphabet
  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
==> passed

Test 3f: check tranform() on random inputs that are circular
         shifts of themselves
  * 5 random strings from unary alphabet
  * 5 random strings from binary alphabet
  * 5 random strings from DNA alphabet
  * 5 random strings from uppercase alphabet
==> passed

Test 4a: check inverseTransform() on text files
  * abra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 21
    - reference entry = 41
    - student:   21 41 42 52 41 43 41 44 41 42 52 41 
    - reference: 41 42 52 41 43 41 44 41 42 52 41 21 

  * zebra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 61
    - reference entry = 7a
    - student:   61 7a 65 62 72 
    - reference: 7a 65 62 72 61 

  * cadabra.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 43 41 44 41 42 52 41 21 41 42 52 
    - reference: 43 41 44 41 42 52 41 21 41 42 52 41 

  * amendments.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 72 74 69 63 6c 65 20 .. 74 65 72 76 65 6e 65 64 2e 
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a 

==> FAILED

Test 4b: check inverseTransform() on corner-case text files
  * alphanum.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 39
    - reference entry = 61
    - student:   39 61 62 63 64 65 66 67 68 .. 30 31 32 33 34 35 36 37 38 
    - reference: 61 62 63 64 65 66 67 68 69 .. 31 32 33 34 35 36 37 38 39 

  * a.txt.bwt
  * stars.txt.bwt
  * couscous.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 73
    - reference entry = 63
    - student:   73 63 6f 75 73 63 6f 75 
    - reference: 63 6f 75 73 63 6f 75 73 

==> FAILED

Test 4c: check inverseTransform() on binary files
  * us.gif.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 3b
    - reference entry = 47
    - student:   3b 47 49 46 38 39 61 8e 01 .. df 7f 03 1e 38 cc 41 00 00 
    - reference: 47 49 46 38 39 61 8e 01 01 .. 7f 03 1e 38 cc 41 00 00 3b 

  * CS_bricks.jpg.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = d9
    - reference entry = ff
    - student:   d9 ff d8 ff e1 00 16 45 78 .. a3 46 8d 01 a3 46 8d 07 ff 
    - reference: ff d8 ff e1 00 16 45 78 69 .. 46 8d 01 a3 46 8d 07 ff d9 

  * rand10K.bin.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = b4
    - reference entry = 1a
    - student:   b4 1a de 9d f2 73 73 0c 05 .. c5 46 04 ae 11 4f d4 bc 2d 
    - reference: 1a de 9d f2 73 73 0c 05 e1 .. 46 04 ae 11 4f d4 bc 2d b4 

==> FAILED

Test 4d: check inverseTransform() of transform() on random inputs
  * 10 random characters from unary alphabet
  * 10 random characters from binary alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 42 42 42 41 41 41 41 42 42 
    - reference: 42 42 42 41 41 41 41 42 42 41 

    - failed on trial 1 of 100
    - input = 'BBBAAAABBA'

  * 10 random characters from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 43
    - reference entry = 41
    - student:   43 41 54 43 43 54 54 54 43 54 
    - reference: 41 54 43 43 54 54 54 43 54 43 

    - failed on trial 1 of 100
    - input = 'ATCCTTTCTC'

  * 10 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 47
    - student:   41 47 4d 50 59 44 51 56 4a 49 
    - reference: 47 4d 50 59 44 51 56 4a 49 41 

    - failed on trial 1 of 100
    - input = 'GMPYDQVJIA'

  * 100 random characters from unary alphabet
  * 1000 random characters from binary alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 42 42 41 41 41 42 41 41 .. 41 42 41 41 41 41 42 41 41 
    - reference: 42 42 41 41 41 42 41 41 41 .. 42 41 41 41 41 42 41 41 41 

    - failed on trial 1 of 100

  * 1000 random characters from DNA alphabet
    - entry 1 of the two sequences are not equal
    - student   entry = 47
    - reference entry = 54
    - student:   47 47 54 41 43 47 54 41 43 .. 47 41 47 43 43 47 54 43 41 
    - reference: 47 54 41 43 47 54 41 43 41 .. 41 47 43 43 47 54 43 41 47 

    - failed on trial 1 of 100

  * 1000 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 58
    - reference entry = 5a
    - student:   58 5a 5a 52 42 4b 56 5a 45 .. 41 46 56 51 53 54 59 42 48 
    - reference: 5a 5a 52 42 4b 56 5a 45 41 .. 46 56 51 53 54 59 42 48 58 

    - failed on trial 1 of 100

==> FAILED

Test 4e: check inverseTransform() of transform() on more random inputs
  * 1000 random characters from ASCII alphabet 
    - entry 0 of the two sequences are not equal
    - student   entry = 10
    - reference entry = 74
    - student:   10 74 20 42 3d 74 15 7e 28 .. 4b 4f 1c 59 00 25 11 19 20 
    - reference: 74 20 42 3d 74 15 7e 28 66 .. 4f 1c 59 00 25 11 19 20 10 

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 80
    - reference entry = 3c
    - student:   80 3c c2 6b ff 0e fc fc 3b .. 69 aa 05 5c c0 52 f4 64 3d 
    - reference: 3c c2 6b ff 0e fc fc 3b ca .. aa 05 5c c0 52 f4 64 3d 80 

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
    - entry 0 of the two sequences are not equal
    - student   entry = a3
    - reference entry = 04
    - student:   a3 04 e5 af f5 2c 3c 15 70 .. db 3e 83 7b 97 7a 12 47 02 
    - reference: 04 e5 af f5 2c 3c 15 70 9d .. 3e 83 7b 97 7a 12 47 02 a3 

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
    - entry 0 of the two sequences are not equal
    - student   entry = f0
    - reference entry = ae
    - student:   f0 ae fc ff 95 bf 34 72 c2 .. 4c 17 99 e4 2f 97 c1 4b 83 
    - reference: ae fc ff 95 bf 34 72 c2 92 .. 17 99 e4 2f 97 c1 4b 83 f0 

    - failed on trial 1 of 100

==> FAILED

Test 5a: check that inverseTransform(transform()) = original on text files
  * abra.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 21
    - reference entry = 41
    - student:   21 41 42 52 41 43 41 44 41 42 52 41 
    - reference: 41 42 52 41 43 41 44 41 42 52 41 21 

  * zebra.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 61
    - reference entry = 7a
    - student:   61 7a 65 62 72 
    - reference: 7a 65 62 72 61 

  * cadabra.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 43
    - student:   41 43 41 44 41 42 52 41 21 41 42 52 
    - reference: 43 41 44 41 42 52 41 21 41 42 52 41 

  * amendments.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 72 74 69 63 6c 65 20 .. 74 65 72 76 65 6e 65 64 2e 
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a 

==> FAILED

Test 5b: check that inverseTransform(transform()) = original on corner-case text files
  * alphanum.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 39
    - reference entry = 61
    - student:   39 61 62 63 64 65 66 67 68 .. 30 31 32 33 34 35 36 37 38 
    - reference: 61 62 63 64 65 66 67 68 69 .. 31 32 33 34 35 36 37 38 39 

  * a.txt
  * stars.txt
  * couscous.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 73
    - reference entry = 63
    - student:   73 63 6f 75 73 63 6f 75 
    - reference: 63 6f 75 73 63 6f 75 73 

==> FAILED

Test 5c: check that inverseTransform(transform()) = original on binary files
  * us.gif
    - entry 0 of the two sequences are not equal
    - student   entry = 3b
    - reference entry = 47
    - student:   3b 47 49 46 38 39 61 8e 01 .. df 7f 03 1e 38 cc 41 00 00 
    - reference: 47 49 46 38 39 61 8e 01 01 .. 7f 03 1e 38 cc 41 00 00 3b 

  * CS_bricks.jpg
    - entry 0 of the two sequences are not equal
    - student   entry = d9
    - reference entry = ff
    - student:   d9 ff d8 ff e1 00 16 45 78 .. a3 46 8d 01 a3 46 8d 07 ff 
    - reference: ff d8 ff e1 00 16 45 78 69 .. 46 8d 01 a3 46 8d 07 ff d9 

  * rand10K.bin
    - entry 0 of the two sequences are not equal
    - student   entry = b4
    - reference entry = 1a
    - student:   b4 1a de 9d f2 73 73 0c 05 .. c5 46 04 ae 11 4f d4 bc 2d 
    - reference: 1a de 9d f2 73 73 0c 05 e1 .. 46 04 ae 11 4f d4 bc 2d b4 

==> FAILED

Test 5d: check that inverseTransform(tranform()) = original on random inputs
  * 10 random characters from binary alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 42
    - reference entry = 41
    - student:   42 41 41 41 42 42 41 42 41 42 
    - reference: 41 41 41 42 42 41 42 41 42 42 

    - failed on trial 1 of 100
    - input = 'AAABBABABB'

  * 10 random characters from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 47
    - reference entry = 54
    - student:   47 54 43 47 54 54 41 41 43 47 
    - reference: 54 43 47 54 54 41 41 43 47 47 

    - failed on trial 1 of 100
    - input = 'TCGTTAACGG'

  * 10 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 4a
    - reference entry = 4f
    - student:   4a 4f 49 5a 4c 46 48 47 51 4b 
    - reference: 4f 49 5a 4c 46 48 47 51 4b 4a 

    - failed on trial 1 of 100
    - input = 'OIZLFHGQKJ'

  * 1000 random characters from binary alphabet
    - entry 1 of the two sequences are not equal
    - student   entry = 41
    - reference entry = 42
    - student:   41 41 42 42 42 42 41 42 41 .. 41 41 41 41 41 41 42 41 42 
    - reference: 41 42 42 42 42 41 42 41 42 .. 41 41 41 41 41 42 41 42 41 

    - failed on trial 1 of 100

  * 1000 random characters from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 54
    - reference entry = 41
    - student:   54 41 47 47 41 43 54 41 54 .. 43 41 43 43 54 47 47 41 41 
    - reference: 41 47 47 41 43 54 41 54 43 .. 41 43 43 54 47 47 41 41 54 

    - failed on trial 1 of 100

  * 1000 random characters from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 46
    - reference entry = 55
    - student:   46 55 4e 56 57 41 51 55 52 .. 4f 49 42 56 55 4e 46 52 44 
    - reference: 55 4e 56 57 41 51 55 52 43 .. 49 42 56 55 4e 46 52 44 46 

    - failed on trial 1 of 100

==> FAILED

Test 5e: check that inverseTransform(tranform()) = original on random inputs
  * 1000 random characters from ASCII alphabet 
    - entry 0 of the two sequences are not equal
    - student   entry = 09
    - reference entry = 33
    - student:   09 33 35 66 04 6f 56 1f 1b .. 18 03 4e 17 79 65 6d 47 30 
    - reference: 33 35 66 04 6f 56 1f 1b 55 .. 03 4e 17 79 65 6d 47 30 09 

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 55
    - reference entry = 3c
    - student:   55 3c 59 27 c6 d5 e8 02 15 .. a1 9d d4 2e 7f 6c 53 4c 40 
    - reference: 3c 59 27 c6 d5 e8 02 15 d9 .. 9d d4 2e 7f 6c 53 4c 40 55 

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0x00)
    - entry 0 of the two sequences are not equal
    - student   entry = 26
    - reference entry = 69
    - student:   26 69 b2 24 c6 22 f5 d6 eb .. 54 98 27 7d 71 5a 19 c8 b2 
    - reference: 69 b2 24 c6 22 f5 d6 eb dd .. 98 27 7d 71 5a 19 c8 b2 26 

    - failed on trial 1 of 100

  * 1000 random characters from extended ASCII alphabet (excluding 0xFF)
    - entry 0 of the two sequences are not equal
    - student   entry = a7
    - reference entry = c0
    - student:   a7 c0 3b af c0 49 87 43 d3 .. eb 6d f2 08 23 6c 0e 54 13 
    - reference: c0 3b af c0 49 87 43 d3 38 .. 6d f2 08 23 6c 0e 54 13 a7 

    - failed on trial 1 of 100

==> FAILED

Test 5f: check that inverseTransform(tranform()) = original
         on random inputs that are circular shifts of themselves
  * random strings from unary alphabet
  * random strings from binary alphabet
    - entry 2 of the two sequences are not equal
    - student   entry = 42
    - reference entry = 41
    - student:   42 42 42 41 41 42 42 42 41 41 
    - reference: 42 42 41 41 42 42 42 41 41 42 

    - failed on trial 1 of 100
    - input = 'BBAABBBAAB'

  * random strings from DNA alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 43
    - reference entry = 47
    - student:   43 47 43 43 54 43 47 43 43 54 43 47 43 43 54 43 47 43 43 54 
    - reference: 47 43 43 54 43 47 43 43 54 43 47 43 43 54 43 47 43 43 54 43 

    - failed on trial 1 of 100
    - input = 'GCCTCGCCTCGCCTCGCCTC'

  * random strings from uppercase alphabet
    - entry 0 of the two sequences are not equal
    - student   entry = 43
    - reference entry = 41
    - student:   43 41 5a 48 50 43 41 5a 48 50 
    - reference: 41 5a 48 50 43 41 5a 48 50 43 

    - failed on trial 1 of 100
    - input = 'AZHPCAZHPC'

==> FAILED

Test 6a: check that transform() calls either close() or flush()
  * amendments.txt
  * aesop.txt
==> passed

Test 6b: check that inverseTransform() calls either close() or flush()
  * amendments.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 72 74 69 63 6c 65 20 .. 74 65 72 76 65 6e 65 64 2e 
    - reference: 41 72 74 69 63 6c 65 20 49 .. 65 72 76 65 6e 65 64 2e 0a 

  * aesop.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 41
    - student:   0a 41 65 73 6f 70 27 73 20 .. 65 72 20 73 75 6e 73 3f 22 
    - reference: 41 65 73 6f 70 27 73 20 46 .. 72 20 73 75 6e 73 3f 22 0a 

==> FAILED

Test 7a: check transform() on large files
  * rand100K.bin
  * world192.txt
==> passed

Test 7b: check inverseTransform() on large files
  * rand100K.bin.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 38
    - reference entry = 73
    - student:   38 73 fe be 6c 9d a3 82 eb .. 8f f5 60 4f 60 99 82 d5 72 
    - reference: 73 fe be 6c 9d a3 82 eb 5e .. f5 60 4f 60 99 82 d5 72 38 

  * world192.txt.bwt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 2a
    - student:   0a 2a 2a 2a 2a 54 68 65 20 .. 65 72 6c 61 6e 64 0d 0a 0d 
    - reference: 2a 2a 2a 2a 54 68 65 20 50 .. 72 6c 61 6e 64 0d 0a 0d 0a 

==> FAILED

Test 7c: check that inverseTransform(transform()) = original on large files
  * rand100K.bin
    - entry 0 of the two sequences are not equal
    - student   entry = 38
    - reference entry = 73
    - student:   38 73 fe be 6c 9d a3 82 eb .. 8f f5 60 4f 60 99 82 d5 72 
    - reference: 73 fe be 6c 9d a3 82 eb 5e .. f5 60 4f 60 99 82 d5 72 38 

  * world192.txt
    - entry 0 of the two sequences are not equal
    - student   entry = 0a
    - reference entry = 2a
    - student:   0a 2a 2a 2a 2a 54 68 65 20 .. 65 72 6c 61 6e 64 0d 0a 0d 
    - reference: 2a 2a 2a 2a 54 68 65 20 50 .. 72 6c 61 6e 64 0d 0a 0d 0a 

==> FAILED


Total: 11/26 tests passed!


================================================================
********************************************************************************
*  MEMORY
********************************************************************************

Analyzing memory of CircularSuffixArray
*-----------------------------------------------------------
Running 10 total tests.

Memory usage of a CircularSuffixArray for a random string of length n.
Maximum allowed memory is 64n + 128.

                 n        bytes
-------------------------------
=> passed       16          216
=> passed       32          312
=> passed       64          504
=> passed      128          888
=> passed      256         1656
=> passed      512         3192
=> passed     1024         6264
=> passed     2048        12408
=> passed     4096        24696
=> passed     8192        49272
==> 10/10 tests passed

Total: 10/10 tests passed!

Estimated student memory (bytes) = 6.00 n + 120.00   (R^2 = 1.000)
================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing CircularSuffixArray
*-----------------------------------------------------------
Running 26 total tests.

Tests  1-13: time to create a circular suffix array for the first
             n character of dickens.txt and call index(i) for each i

            [ max allowed time = 10 seconds and <= 12x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.01       0.00      10.98
=> passed     2000       0.00       0.00       0.89
=> passed     4000       0.00       0.00       0.82
=> passed     8000       0.00       0.00       1.02
=> passed    16000       0.01       0.01       0.94
=> passed    32000       0.02       0.01       1.45
=> passed    64000       0.03       0.01       2.13
=> passed   128000       0.02       0.01       2.08
=> passed   256000       0.04       0.03       1.48
=> passed   512000       0.09       0.05       1.77
=> passed  1024000       0.20       0.11       1.73
=> passed  2048000       0.42       0.30       1.39
=> passed  4096000       1.13       0.79       1.42

Estimated running time (using last 6 measurements)
    = 4.43e-08 * n^1.11  (R^2 = 1.00)


Tests 14-26: time to create circular suffix array for n random ASCII characters
            and call index(i) for each i

            [ max allowed time = 10 seconds and <= 20x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       1.72
=> passed     2000       0.00       0.00       0.81
=> passed     4000       0.00       0.00       0.74
=> passed     8000       0.00       0.00       1.04
=> passed    16000       0.00       0.00       1.69
=> passed    32000       0.00       0.00       2.83
=> passed    64000       0.01       0.00       4.17
=> passed   128000       0.02       0.01       2.52
=> passed   256000       0.04       0.02       2.00
=> passed   512000       0.10       0.10       1.04
=> passed  1024000       0.18       0.11       1.55
=> passed  2048000       0.41       0.27       1.51
=> passed  4096000       1.03       0.38       2.71

Estimated running time (using last 6 measurements)
    = 2.59e-08 * n^1.14  (R^2 = 1.00)


Total: 26/26 tests passed!


================================================================



********************************************************************************
*  TIMING
********************************************************************************

Timing MoveToFront
*-----------------------------------------------------------
Running 38 total tests.

Test 1: count calls to methods in BinaryStdOut from encode()
  * abra.txt
  * amendments.txt
==> passed

Test 2: count calls to methods in BinaryStdOut from decode()
  * abra.txt.mtf
  * amendments.txt.mtf
==> passed

Tests  3-12: Timing encode() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.64
=> passed     2000       0.00       0.00       1.14
=> passed     4000       0.01       0.01       1.12
=> passed     8000       0.01       0.01       1.19
=> passed    16000       0.02       0.02       1.18
=> passed    32000       0.05       0.04       1.23
=> passed    64000       0.12       0.09       1.28
=> passed   128000       0.23       0.19       1.20
=> passed   256000       0.41       0.34       1.19

Estimated running time (using last 6 measurements)
     = 9.52e-07 * n^1.05  (R^2 = 1.00)


Tests  13-20: Timing encode() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       1.39
=> passed     2000       0.00       0.00       1.36
=> passed     4000       0.01       0.01       1.36
=> passed     8000       0.01       0.01       1.39
=> passed    16000       0.03       0.02       1.39
=> passed    32000       0.05       0.03       1.35
=> passed    64000       0.10       0.08       1.35
=> passed   128000       0.21       0.15       1.34
=> passed   256000       0.35       0.25       1.36

Estimated running time (using last 6 measurements)
     = 3.48e-06 * n^0.93  (R^2 = 1.00)


Tests 21-29: Timing decode() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       1.14
=> passed     2000       0.00       0.00       1.69
=> passed     4000       0.01       0.00       1.16
=> passed     8000       0.01       0.01       1.21
=> passed    16000       0.02       0.02       1.21
=> passed    32000       0.04       0.03       1.24
=> passed    64000       0.08       0.07       1.23
=> passed   128000       0.17       0.13       1.28
=> passed   256000       0.36       0.29       1.27

Estimated running time (using last 6 measurements)
     = 1.08e-06 * n^1.02  (R^2 = 1.00)


Tests 30-38: Timing decode() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 4x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       1.32
=> passed     2000       0.00       0.00       1.24
=> passed     4000       0.01       0.00       1.36
=> passed     8000       0.01       0.01       1.41
=> passed    16000       0.02       0.02       1.32
=> passed    32000       0.05       0.04       1.24
=> passed    64000       0.11       0.09       1.34
=> passed   128000       0.18       0.12       1.48
=> passed   256000       0.37       0.28       1.30

Estimated running time (using last 6 measurements)
     = 1.29e-06 * n^1.01  (R^2 = 0.99)


Total: 38/38 tests passed!


================================================================



********************************************************************************
*  TIMING (substituting reference CircularSuffixArray)
********************************************************************************

Timing BurrowsWheeler
*-----------------------------------------------------------
Running 95 total tests.

Test 1: count calls to methods in CircularSuffixArray from transform()
  * abra.txt
  * amendments.txt
==> passed

Test 2: count calls to methods in CircularSuffixArray from inverseTransform()
  * abra.txt.bwt
  * amendments.txt.bwt
==> passed

Test 3: count calls to methods in BinaryStdOut from transform()
  * abra.txt
  * amendments.txt
==> passed

Test 4: count calls to methods in BinaryStdOut from inverseTransform()
  * abra.txt.bwt
  * amendments.txt.bwt
==> passed

Tests  5-17: timing transform() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.11
=> passed     2000       0.00       0.00       0.50
=> passed     4000       0.00       0.00       0.58
=> passed     8000       0.00       0.00       0.67
=> passed    16000       0.00       0.01       0.48
=> passed    32000       0.01       0.01       0.50
=> passed    64000       0.01       0.02       0.44
=> passed   128000       0.02       0.02       0.99
=> passed   256000       0.04       0.04       1.00
=> passed   512000       0.08       0.08       0.97
=> passed  1024000       0.17       0.16       1.01
=> passed  2048000       0.43       0.42       1.04
=> passed  4096000       0.97       0.89       1.10

Estimated running time as a function of n (using last 6 measurements)
    = 2.56e-08 * n^1.14  (R^2 = 1.00)


Tests 18-30: timing transform() with first n character of random.bin
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.90
=> passed     2000       0.00       0.00       0.82
=> passed     4000       0.00       0.00       0.95
=> passed     8000       0.00       0.00       1.18
=> passed    16000       0.00       0.00       0.97
=> passed    32000       0.01       0.01       1.15
=> passed    64000       0.01       0.01       0.97
=> passed   128000       0.02       0.02       1.00
=> passed   256000       0.04       0.04       0.99
=> passed   512000       0.09       0.09       1.00
=> passed  1024000       0.19       0.19       1.04
=> passed  2048000       0.59       0.54       1.09
=> passed  4096000       1.14       1.46       0.78

Estimated running time as a function of n (using last 6 measurements)
    = 1.46e-08 * n^1.19  (R^2 = 0.99)


Tests 31-43: timing transform() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.74
=> passed     2000       0.00       0.00       0.99
=> passed     4000       0.00       0.00       0.89
=> passed     8000       0.00       0.00       0.65
=> passed    16000       0.00       0.00       1.04
=> passed    32000       0.00       0.00       0.99
=> passed    64000       0.00       0.00       1.01
=> passed   128000       0.01       0.01       0.96
=> passed   256000       0.01       0.01       1.01
=> passed   512000       0.02       0.02       1.01
=> passed  1024000       0.05       0.06       0.72
=> passed  2048000       0.09       0.09       1.06
=> passed  4096000       0.16       0.17       0.96

Estimated running time as a function of n (using last 6 measurements)
    = 7.78e-08 * n^0.96  (R^2 = 1.00)


Tests 44-56: timing inverseTransform() with first n character of dickens.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       0.66
=> passed     2000       0.00       0.00       0.49
=> passed     4000       0.00       0.00       0.36
=> passed     8000       0.00       0.00       0.46
=> passed    16000       0.00       0.00       0.33
=> passed    32000       0.00       0.00       1.35
=> passed    64000       0.00       0.00       1.47
=> passed   128000       0.01       0.01       1.41
=> passed   256000       0.01       0.01       1.92
=> passed   512000       0.03       0.02       1.63
=> passed  1024000       0.09       0.06       1.64
=> passed  2048000       0.36       0.15       2.46
=> passed  4096000       0.64       0.39       1.65

Estimated running time as a function of n (using last 6 measurements)
    = 9.23e-10 * n^1.34  (R^2 = 0.98)


Tests 57-69: timing inverseTransform() with first n character of random.bin
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1024       0.00       0.00       2.14
=> passed     2048       0.00       0.00       1.47
=> passed     4096       0.00       0.00       1.47
=> passed     8192       0.00       0.00       1.48
=> passed    16384       0.00       0.00       1.56
=> passed    32768       0.00       0.00       1.60
=> passed    65536       0.00       0.00       1.49
=> passed   131072       0.01       0.00       1.43
=> passed   262144       0.01       0.01       1.46
=> passed   524288       0.03       0.02       1.58
=> passed  1048576       0.08       0.05       1.62
=> passed  2097152       0.18       0.11       1.61
=> passed  4194304       0.52       0.39       1.33

Estimated running time as a function of n (using last 6 measurements)
    = 1.20e-09 * n^1.30  (R^2 = 1.00)


Tests 70-82: timing inverseTransform() with first n character of abab.txt
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1000       0.00       0.00       1.31
=> passed     2000       0.00       0.00       1.34
=> passed     4000       0.00       0.00       1.38
=> passed     8000       0.00       0.00       1.08
=> passed    16000       0.00       0.00       1.42
=> passed    32000       0.00       0.00       1.36
=> passed    64000       0.00       0.00       1.39
=> passed   128000       0.00       0.00       1.63
=> passed   256000       0.01       0.01       1.45
=> passed   512000       0.02       0.01       1.17
=> passed  1024000       0.03       0.02       1.53
=> passed  2048000       0.07       0.04       1.52
=> passed  4096000       0.14       0.09       1.57

Estimated running time as a function of n (using last 6 measurements)
    = 3.33e-08 * n^1.00  (R^2 = 1.00)


Tests 83-95: timing inverseTransform() with first n character of cyclic.bin
             [ max allowed time = 2 seconds and <= 8x reference ]

                 n    student  reference      ratio
---------------------------------------------------
=> passed     1024       0.00       0.00       1.43
=> passed     2048       0.00       0.00       1.48
=> passed     4096       0.00       0.00       1.50
=> passed     8192       0.00       0.00       1.52
=> passed    16384       0.00       0.00       1.44
=> passed    32768       0.00       0.00       1.42
=> passed    65536       0.00       0.00       1.53
=> passed   131072       0.01       0.00       1.20
=> passed   262144       0.02       0.01       1.61
=> passed   524288       0.03       0.03       1.26
=> passed  1048576       0.06       0.04       1.42
=> passed  2097152       0.32       0.14       2.22
=> passed  4194304       0.68       0.32       2.12

Estimated running time as a function of n (using last 6 measurements)
    = 5.86e-10 * n^1.36  (R^2 = 0.98)


Total: 95/95 tests passed!


================================================================



